# Application configuration
# 
server:
  port: 8080
  servlet:
    context-path: /product-order-service
  tomcat:
    max-threads: 500  # Optimized for high concurrency (10,000 RPS)
    min-spare-threads: 50
    accept-count: 200
    max-connections: 10000
    connection-timeout: 20000

# gRPC Server Configuration (disabled for now)
# grpc:
#   server:
#     port: 9091

spring:
  application:
    name: product-order-service
  main:
    allow-bean-definition-overriding: true
    allow-circular-references: true
  autoconfigure:
    exclude: org.springframework.boot.autoconfigure.kafka.KafkaAutoConfiguration
  threads:
    virtual:
      enabled: true
  
  # Database Configuration
  datasource:
    url: jdbc:h2:mem:testdb
    driver-class-name: org.h2.Driver
    username: sa
    password: password
  
  # JPA Configuration
  jpa:
    hibernate:
      ddl-auto: create-drop
    show-sql: true
    properties:
      hibernate:
        dialect: org.hibernate.dialect.H2Dialect
        format_sql: true
  
  # H2 Console Configuration
  h2:
    console:
      enabled: true
      path: /h2-console
      settings:
        web-allow-others: true
  
  # Cache Configuration - Redis
  cache:
    type: redis
    redis:
      time-to-live: 600000 # 10 minutes
      cache-null-values: false
      enable-statistics: true
  
  # Redis Configuration (Optimized for high concurrency)
  data:
    redis:
      host: localhost
      port: 6379
      password: ${REDIS_PASSWORD:}
      timeout: 2000ms
      lettuce:
        pool:
          max-active: 50  # Increased for high concurrency
          max-idle: 20
          min-idle: 10
          max-wait: 2000ms
  
  # Kafka Configuration
  kafka:
    bootstrap-servers: ${KAFKA_BOOTSTRAP_SERVERS:localhost:9092}
    consumer:
      group-id: ${KAFKA_CONSUMER_GROUP:product-order-service-group}
      auto-offset-reset: earliest
      key-deserializer: org.apache.kafka.common.serialization.StringDeserializer
      value-deserializer: org.apache.kafka.common.serialization.StringDeserializer
    producer:
      key-serializer: org.apache.kafka.common.serialization.StringSerializer
      value-serializer: org.apache.kafka.common.serialization.StringSerializer
    admin:
      bootstrap-servers: ${KAFKA_BOOTSTRAP_SERVERS:localhost:9092}

# Kafka Topics Configuration
kafka:
  topics:
    order:
      created: ${KAFKA_TOPIC_ORDER_CREATED:order.created}
      status-updated: ${KAFKA_TOPIC_ORDER_STATUS_UPDATED:order.status.updated}
      cancelled: ${KAFKA_TOPIC_ORDER_CANCELLED:order.cancelled}
      completed: ${KAFKA_TOPIC_ORDER_COMPLETED:order.completed}
    payment:
      processed: ${KAFKA_TOPIC_PAYMENT_PROCESSED:payment.processed}
      failed: ${KAFKA_TOPIC_PAYMENT_FAILED:payment.failed}
      refunded: ${KAFKA_TOPIC_PAYMENT_REFUNDED:payment.refunded}
      cancelled: ${KAFKA_TOPIC_PAYMENT_CANCELLED:payment.cancelled}
      retry: ${KAFKA_TOPIC_PAYMENT_RETRY:payment.retry}
    product:
      stock-updated: ${KAFKA_TOPIC_PRODUCT_STOCK_UPDATED:product.stock.updated}

# Security Configuration
security:
  jwt:
    secret: myVerySecureSecretKeyThatIsAtLeast32CharactersLongForJWT256BitSecurity
    expiration: 86400000 # 24 hours

# Management and Monitoring
management:
  endpoints:
    web:
      exposure:
        include: health,info,metrics,prometheus
  endpoint:
    health:
      show-details: always
  metrics:
    export:
      prometheus:
        enabled: true

# Swagger/OpenAPI Configuration
springdoc:
  api-docs:
    path: /api-docs
  swagger-ui:
    path: /swagger-ui.html
    operationsSorter: method
    tagsSorter: alpha
  default-produces-media-type: application/json
  default-consumes-media-type: application/json
  show-actuator: true

# AWS S3 Configuration
aws:
  s3:
    bucket-name: ${S3_BUCKET:my-pos-bucket-125}
    region: ${S3_REGION:ap-south-1}
    access-key: ${AWS_ACCESS_KEY_ID:}
    secret-key: ${AWS_SECRET_ACCESS_KEY:}

# OpenAPI/Swagger Configuration
openapi:
  info:
    title: Product Order Service API
    version: 1.0.0
    description: E-commerce platform API for product and order management
  servers:
    - url: /product-order-service
      description: Current Server
    - url: ${OPENAPI_LOCAL_SERVER:http://localhost:8080/product-order-service}
      description: Local Development
    - url: ${OPENAPI_AWS_SERVER:http://13.202.157.59:8080/product-order-service}
      description: AWS EC2 Instance
  security:
    scheme-name: bearerAuth
    scheme-type: HTTP
    scheme: bearer
    bearer-format: JWT

# Logging Configuration
logging:
  level:
    com.ecommerce.productorder: DEBUG
    org.springframework.security: DEBUG
    org.springframework.kafka: INFO
  pattern:
    console: "%d{yyyy-MM-dd HH:mm:ss} - %msg%n"
    file: "%d{yyyy-MM-dd HH:mm:ss} [%thread] %-5level %logger{36} - %msg%n"
  file:
    name: logs/product-order-service.log

---
# Production Configuration
spring:
  config:
    activate:
      on-profile: prod
  
  datasource:
    url: jdbc:mysql://localhost:3306/ecommerce_db
    driver-class-name: com.mysql.cj.jdbc.Driver
    username: ${DB_USERNAME:root}
    password: ${DB_PASSWORD:password}
  
  jpa:
    hibernate:
      ddl-auto: validate
    show-sql: false
    properties:
      hibernate:
        dialect: org.hibernate.dialect.MySQL8Dialect
  
  # Redis Configuration for Production
  data:
    redis:
      host: ${REDIS_HOST:localhost}
      port: ${REDIS_PORT:6379}
      password: ${REDIS_PASSWORD:}
      timeout: 2000ms
      lettuce:
        pool:
          max-active: 50
          max-idle: 20
          min-idle: 10
          max-wait: 2000ms
  
  # Cache Configuration for Production
  cache:
    type: redis
    redis:
      time-to-live: 3600000 # 1 hour
      cache-null-values: false
      enable-statistics: true

  kafka:
    bootstrap-servers: ${KAFKA_BOOTSTRAP_SERVERS:localhost:9092}

# Production Logging
logging:
  level:
    com.ecommerce.productorder: INFO
    org.springframework.security: WARN
    org.springframework.kafka: WARN
  file:
    name: /var/log/product-order-service/application.log
